Added `Attribute.reuse(**kwargs)`, which allows you to reuse (and simultaneously `evolve()`) attribute definitions from already defined classes:

```py
@define
class A:
    a: int = 100

@define
class B(A):
    a = fields(B).a.reuse(default=200)

assert B().a == 200
```

To preserve attribute ordering of `reuse`d attributes, `inherited` was exposed as a public keyword argument to `attrib` and friends. Setting `inherited=True` manually on a *attrs* field definition simply acts as a flag to tell *attrs* to use the parent class ordering, *if* it can find an attribute in the parent MRO with the same name. Otherwise, the field is simply added to the class's attribute list as if `inherited=False`.

```py
@define
class Parent:
    x: int = 1
    y: int = 2

@define
class ChildOrder(Parent):
    x = fields(Parent).x.reuse(default=3)
    z: int = 4

assert repr(ChildOrder()) == "ChildOrder(y=2, x=3, z=4)"

@define
class ParentOrder(Parent):
    x = fields(Parent).y.reuse(default=3, inherited=True)
    z = fields(ChildOrder).z.reuse(inherited=True) # `inherited` does nothing here

assert repr(ParentOrder()) == "ParentOrder(x=3, y=2, z=4)"
```

Incidentally, because this behavior was added to `field`, this gives you a little more control of attribute ordering even when not using `reuse()`:

```py
@define
class Parent:
    a: int
    b: int = 10

class Child(Parent):
    a: str = field(default="test", inherited=True)

assert repr(Child()) == "Child(a='test', b=10)"
```
